tap dispatching - 반복자가 가지고 있는 특성별로 알고리즘이 사용가능한지를 판단해 forwarding하는 기법 

advance함수를 만들어가면서 연습했음. advance함수에서 인자로 tag 전달함 전달할 때 중요한점은 ()를 이용해 객체를 만들어서 넘겨준다는 것. tag dispatching을 이용한 이유는 반복자 마다 특성이 다르고 성능이 다르다. 만약, list일 경우 + 연산이 제공되지 않아 ++ 연산을 해야한다. 하지만 vector연산 같은 경우 + 연산이 제공 되기 때문에 + 연산을 통해 성능을 향상 시킬 수 있다.

inline함수

치환하는 함수.

매크로와 동일하게 컴파일 과정에서 치환된다
성능은 인라인 함수가 그냥 함수보다 좋다. 일단 함수 콜이 없는것이 장점이다.
하지만 obj파일의 크기가 커지는 단점이 있다. 구글 c++ 코딩 스타일을 찾아 봤을 경우 10줄 이내로 작성을할것을 권하고 있다. 

inline함수 같은 경우 파일을 분할 할 경우 조심해야한다. 헤더 파일 만 두게 된다면 컴파일 과정에서는 따로 컴파일 되기 때문에 링킹과정에서 오류가 발생한다. 그래서 헤더파일에 인라인 함수를 적어줘야한다. 


반복자 카테고리 

반복자라고 다 동일한 연산을 제공하지 않는다. 데이터 구조 특성상 제공되는 것도 있고 아닌 것도 있다. 그걸 주의해야한다. 그걸 분류하기 위해 반복자 카테고리를 정의했다. 반복자에는 using을 이용해 카테고리를 재정의해서 사용한다. 

1. ++, * 연산자 입력 - 입력반복자
2. 출력 - 출력 연산자
3. 입력반복자를 포함하고 multi pass 개념 (동일한 한 요소를 두개가 가리키는 경우) - 전방 반복자
4. 전반 반복자를 포함하고 -- => 양방향반복자
5. 양방향 반복자를 포함하고 +, [] 연산을 제공 - 임의 접근 반복자
6. c++17 에는 실제 물리 주소와 논리적 주소가 같은 연산을 제공하는 것 - 연이은 반복자 (tag 제공 안함) 
