### generic function

- 호출 하기 전까지는 매개변수의 타입을 알 수 없는 함수 -> 지네릭 함수 

- 우리는 이전의 find함수를 배웠다. find함수는 어떤 타입도 전부 받을 수 있었다. find함수가 '적절한 타입'의 인수를 허용한다는 게 중요하다.

- 컨테이너를 직접 작성할때는 적절한 모든 연산을 지원하는 반복자를 반드시 제공 
- 반복자는 C++ 의존하는 것이 아니라 표준 라이브러리를 구성하는 핵심요소이자 제네릭 함수를 유용하게 만드는 요소 


### 알려지지 않은 타입의 중앙값

- 제네릭 함수를 구현하는 프로그래밍 언어의 특징을 template function을 사용한다라고 칭함 
- template parameter의 타입은 다르지만 동일하게 동작하는 함수 집합 정의를 단일화 할 수 있다. 오늘 본 내용 
- 함수의 인자는 다르지만 기능은 동일하다 


- 템플릿의 핵심 개념은 서로 다른 타입의 객체가 공통 동작을 공유할 수 있다는 점!! 
- 템플릿을 사용할 때 비로소 타입을 알 수 있다. (컴파일 링커 작업할 떄 알 수 있음)


- 템플릿 헤더는 템플릿 함수를 정의한다는 것과 해당 함수에 타입 매게변수가 있다는 것을 구현체에 알려주는 역할 
- 함수를 호출하면 구현체는 타입네임에 바인딩 시킴 
- 함수호출 부에서 타입을 예측하여 특정 버전을 작성한 것 처럼 나타내는 것을 인스턴스화 라고 한다. 

#### typename 
- 구현체가 T의 타입을 아직 알지 못하는 상태에서 템플릿 함수의 맴버변수를 사용할 때 명시적으로 표기해야함. 표준 라이브러리는 T가 타입 이름이라는 것을 알 수 있지만, 구현체에서는 알기 힘들다. 따라서 템플릿 요소를 쓸 때 typename으로 명시해줘야함 


### 제네릭 함수 및 타입
- 템플릿을 설계하고 사용할 떄 어려운 점은 템플릿과 템플릿에서 사용할 수 있는 '적절한 타입' 사이의 관계를 정확히 이해하는 것
    - 타입 의존성 
    - median 함수에 전달한 벡터가 저장하는 객체 타입은 + 연산과 / 연산을 반드시 지원해야함. 이러한 연산은 산술 연산의미와 일치 한다면 더 좋은데 이 경우 일치함. 

    - 템플릿과 타입 변환 사이의 관계에서 일어남 
    - find함수를 사용할 때, find (a,b, 0) , find(a,b, 0.0)에서 타입 달라짐. 반복자 + 매게변수인데.. 매게변수가 int,double타입이냐에따라 달라짐. 
    - max함수에서 전달하는 인자는 동일해야함.. 
    - 앞에서 썼듯이 string::size_type maxlend = 0; 을 통해서 타입을 일치시켜줬다. 그 이유는 int int 가 넘어가면 비교 연산을 할 때 문제가 되지 않지만 double int와 같이 서로 다른 타입이 넘어가게 된다면 문제가 됨.



### 데이터 구조의 독립성 

- vector<T> 를 이용해 타입 독립성이 아닌 컨테이너로 확장시켜 생각해보자. 데이터 구조를 아우르는 컨테이너의 종류에 상관없이 find를 호출 해보자

- find(iterator, iterator, parameter);
 -> 왜? container.find(parameter); find(container, parameter); 하지 않는 이유는 무엇일까? 
    1. 컨테이너 즉, 연속적으로 데이터에 접근가능한 컨테이너 관계없이 접근하도록 하기 위해서 (공통적으로 사용)
    2. find함수에 직접 container를 전달하지 않고 반복자를 전달하는 이유는? 
        -> 특정 구간을 찾기 위해서.. 만약 없다고 생각하면..
    3. 제네릭 함수가 컨테이너 대신 반복자를 인수로 전달 받는 이유는 좀 더 복잡함
        일반적으로 반복자는 컨테이너가 포함하지 않는 요소에 접근할 수 있다. -> e.g. rbegin() 사용 못함 
